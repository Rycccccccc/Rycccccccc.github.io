<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据结构/02 复杂</title>
    <link href="/2021/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02%20%E5%A4%8D%E6%9D%82/"/>
    <url>/2021/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02%20%E5%A4%8D%E6%9D%82/</url>
    
    <content type="html"><![CDATA[<h1 id="01-复杂度"><a href="#01-复杂度" class="headerlink" title="01 复杂度"></a>01 复杂度</h1><hr><p>title: 01、复杂度<br>date: 2021-04-01<br>tags: [数据结构]<br>categories:</p><ul><li>数据结构<br>index_img: /img/default.png</li></ul><hr><h2 id="1、什么是算法"><a href="#1、什么是算法" class="headerlink" title="1、什么是算法"></a>1、什么是算法</h2><ul><li>算法是用来解决特定问题的一系列的执行步骤</li><li>使用不同的算法，解决同一个问题，效率可能相差非常大</li></ul><h2 id="2、如何判断一个算法的好坏"><a href="#2、如何判断一个算法的好坏" class="headerlink" title="2、如何判断一个算法的好坏"></a>2、如何判断一个算法的好坏</h2><ul><li>正确性、可读性、健壮性（对不合理输入的反应能力和处理能力）</li><li>时间复杂度（time complexity） : 估算程序指令的执行次数（执行时间）</li><li>空间复杂度（space complexity）: 估算所需占用的存储空间</li><li><h2 id="3、大O-表示法（Big-O）"><a href="#3、大O-表示法（Big-O）" class="headerlink" title="3、大O 表示法（Big O）"></a>3、大O 表示法（Big O）</h2></li><li>一般用大O表示法来描述复杂度，它表示的是数据规模n 对应的复杂度</li><li>忽略常数、系数、低阶<ul><li>9 &gt;&gt; O(1)</li><li>2n + 3 &gt;&gt; O(n)</li><li>n^2 + 2n + 6 &gt;&gt; O(n^2)</li><li>4n^3 + 2n^2 + 6 &gt;&gt; O(n^3)</li></ul></li><li>注意： 大O表示法仅仅是一种粗略的分析模型，是一种估算，能帮助我们短时间了解一个算法的执行效率</li></ul><h2 id="4、对数阶的细节"><a href="#4、对数阶的细节" class="headerlink" title="4、对数阶的细节"></a>4、对数阶的细节</h2><ul><li>对数阶一般忽略底数 $log_2{n}$ = $log_2{9}$ * $log_9{n}$</li><li>所以 $log_2{n}$  、 $log_2{9}$ 统称为 $log_{n}$</li></ul><h2 id="5、常见的复杂度"><a href="#5、常见的复杂度" class="headerlink" title="5、常见的复杂度"></a>5、常见的复杂度</h2><table><thead><tr><th align="center">执行次数</th><th align="center">复杂度</th><th align="center">非正式术语</th></tr></thead><tbody><tr><td align="center">12</td><td align="center">O(1)</td><td align="center">常数阶</td></tr><tr><td align="center">2n + 3</td><td align="center">O(n)</td><td align="center">线性阶</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>02、OpenGL专业名称解析</title>
    <link href="/2020/08/22/OpenGL/02%20OpenGL%20%E4%B8%93%E4%B8%9A%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90/"/>
    <url>/2020/08/22/OpenGL/02%20OpenGL%20%E4%B8%93%E4%B8%9A%E5%90%8D%E7%A7%B0%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="0、OpenGl-两大宝书"><a href="#0、OpenGl-两大宝书" class="headerlink" title="0、OpenGl 两大宝书"></a>0、OpenGl 两大宝书</h1><ul><li>红宝书</li><li>蓝宝书<br>里面有很多经典案例，值得研究。<br><img src="https://raw.githubusercontent.com/Rycccccccc/Rycccccccc.github.io/master/img/OpenGL/OpenGL_Book.png" srcset="/img/loading.gif" alt="image"></li></ul><hr><h1 id="1、OpenGL-上下文（context）"><a href="#1、OpenGL-上下文（context）" class="headerlink" title="1、OpenGL 上下文（context）"></a>1、OpenGL 上下文（context）</h1><ul><li><p>在应用程序调用任何OpenGL 的指令之前，需要安排首先创建一个OpenGL的上下文。这个上下文是一个非常庞大的状态机，保存了OpenGL 中的各种状态，这也是OpenGl 指令执行的基础。</p></li><li><p>OpenGl 是一个面向过程的函数，本质上都是对OpenGL上下文这个庞大的状态机中的某个状态或者对象进行操作，当然得首先把这个对象设置为当前对象。因此，通过对OpenGL指令的封装，是可以将OpenGL的相关调用封装成一个面向对象的图形API的。</p></li><li><p>由于OpenGL上下文是一个巨大的状态机，切换上下文往往会产生较大的开销，但是不同的绘制模块，可能需要使用完全独立的状态管理。因为，可以在应用程序中分别创建多个不同的上下文，在不同线程中使用不同的上下文，上下文之间共享纹理、缓冲区等资源。这样的方案，会比反复切换上下文或者大量修改渲染状态，更加合理高效。</p></li></ul><h1 id="2、OpenGL-状态机"><a href="#2、OpenGL-状态机" class="headerlink" title="2、OpenGL 状态机"></a>2、OpenGL 状态机</h1><ul><li><p>状态机是理论上的一种机器。描述了一个对象在其生命周期内所经历的各种状态，状态间的转变，发生转变的动因，条件以及转变中所执行的活动。因此具有以下特点：</p><ul><li>有记忆功能，能记住当前的状态。</li><li>可以接收输入，根据输入的内容和自己的原先状态，修改自己当前状态，并且可以有对应输出。</li><li>当进入特殊状态（停机状态）的时候，便不再接收输入，停止工作。</li></ul></li><li><p>类推到OpenGL 中来，可以这么理解：</p><ul><li>OpenGL可以记录自己的状态（比如当前使用的颜色，是否开启了混合功能等）</li><li>OpenGL可以接收输入（当调用OpenGL函数的时候，实际上可以看出OpenGL在接收我们的输入，例如调用 <font color="red">glColor3f</font> ,则OpenGL 接收到这个输入后会修改自己的当前颜色这个状态）</li><li>OpenGL可以进入停止状态，不再接收输入。在程序退出前，OpenGL总会先停止工作。</li></ul></li></ul><h1 id="3、渲染"><a href="#3、渲染" class="headerlink" title="3、渲染"></a>3、渲染</h1><ul><li>将图形/图像数据转换成2D空间图像操作叫做渲染 <font color="red">Rendering</font><br>也就是将图片、按钮、视频 显示绘制到屏幕上的过程。 解码图片—&gt; 渲染。</li></ul><h1 id="4、顶点数组VertexArray-和-顶点缓冲区VertexBuffer"><a href="#4、顶点数组VertexArray-和-顶点缓冲区VertexBuffer" class="headerlink" title="4、顶点数组VertexArray 和 顶点缓冲区VertexBuffer"></a>4、顶点数组VertexArray 和 顶点缓冲区VertexBuffer</h1><ul><li><p>画图一般是先画好图像的骨架，然后再往骨架里面填充颜色，这对于OpenGL 也是一样。顶点数据就是要画的图像的骨架，和现实中不同的是，OpenGL 中的图像都是由图元组成。在OpenGL ES中，有三种类型的图元：点、线、三角形。那这些顶点数据最终是存储在哪里的呢？开发者可以选择设定函数指针，在调用绘制方法的时候，直接由内存传入顶点数据，也就是说这部分数据之前是存储在内存当中的，被称为顶点数组。而性能更高的做法是，提前分配一块显存，将顶点数据预先传入到显存当中。这部分的显存，就被称为顶点缓冲区。</p><p>顶点数据存放的位置区别：<br>顶点数组：顶点数据 —-&gt; 内存中<br>顶点缓存区：顶点数据 —-&gt; GPU 显存<br>位图：120x120像素的图片，转成位图大小：120x120xRGBA = 14400x4 位图（纹理）</p></li><li><p>顶点指的是我们在绘制一个图形时，它的顶点位置数据，而这个数据可以直接存储在数组中或者将其缓存到GPU内存中。</p></li></ul><h1 id="5、着色器渲染过程"><a href="#5、着色器渲染过程" class="headerlink" title="5、着色器渲染过程"></a>5、着色器渲染过程</h1><ul><li>在渲染过程中，必须存储2种着色器，分别是顶点着色器和片元着色器。<ul><li>顶点着色器是第一个着色器，处理顶点。</li><li>片元着色器是最后一个，处理像素点颜色</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Rycccccccc/Rycccccccc.github.io/master/img/OpenGL/Rendering_flow.png" srcset="/img/loading.gif" alt="image"></p><h1 id="6、着色器程序Shader"><a href="#6、着色器程序Shader" class="headerlink" title="6、着色器程序Shader"></a>6、着色器程序Shader</h1><ul><li><p>就全面的将固定渲染管线架构变成了可编程渲染管线。因此，OpenGL 在实际调用绘制函数之前，还需要指定一个shader 编译成的着色器程序。常见的着色器主要有：</p><ul><li>顶点着色器（<font color="red">VertexShader</font>）<ul><li>作用1：确定位置，</li><li>作用2：缩放、平移、旋转位置换算，</li><li>作用3：手机端显示3D 手机屏幕实际为2D，3D图形数据进行2D（投影换算）</li></ul></li><li>片元着色器（<font color="red">FragmentShader</font>）<ul><li>也叫做像素着色器：处理一个一个的像素点。</li><li>如果进行图片的饱和度调整，也是需要在这个着色器修改。</li></ul></li><li>像素着色器（<font color="red">PixelShader</font>）</li><li>几何着色器（<font color="red">GeometryShader</font>）</li><li>曲面细分着色器（<font color="red">TessellationShader</font>）<br>片段着色器和像素着色器只是在OpenGL和DX中的不同叫法而已。可惜的是直到OpenGLES 3.0 ，依然只支持了顶点着色器和片段着色器这两个最基础的着色器。</li></ul></li><li><p>OpenGL 在处理shader 时，和其它编译器一样。通过编译、链接等步骤，生成了着色器程序（<font color="red">glProgram</font>）,着色器程序同时包含了顶点着色器和片段着色器的运算逻辑。在OpenGL 进行绘制的时候，首先由顶点着色器对传入的顶点数据进行运算。再通过图元装配，将顶点转换为图元。然后进行光栅化，将图元这种矢量图形，转换为栅格化数据。最后，将栅格化数据传入片段着色器中进行运算。片段着色器会对格栅化数据中的每一个像素进行运算，并决定像素的颜色。</p></li></ul><h1 id="7、管线"><a href="#7、管线" class="headerlink" title="7、管线"></a>7、管线</h1><ul><li>在OpenGL下渲染图形，就会有经历一个一个节点。而这样的操作可以理解管线。可以想象为流水线。每个任务类似流水线般执行，任务之间有先后顺序。管线是个抽象的概念，之所以称之为管线是因为显卡在处理数据的时候是按照一个固定的顺序来的，而且严格按照这个顺序。这个顺序不能打破的。</li></ul><h1 id="8、固定管线-存储着色器"><a href="#8、固定管线-存储着色器" class="headerlink" title="8、固定管线/存储着色器"></a>8、固定管线/存储着色器</h1><ul><li><p>在早期的OpenGl 版本，它封装了很多种着色器程序块内置的一段包含了光照、坐标变换、裁剪等诸多功能的固定<strong>shader</strong> 程序来完成，来帮助开发者完成图形的渲染。而开发者只需要传入相应的参数，就能快速完成图形的渲染。类似于iOS 开发会封装很多API,而我们只需要调用，就可以实现功能。不需要关注底层实现原理。</p></li><li><p>但是由于OpenGL 的使用场景非常丰富，固定管线或存储着色器无法完成每一个业务，这时将相关部分开放可编程。</p></li></ul><h1 id="9、顶点着色器-VertextShader"><a href="#9、顶点着色器-VertextShader" class="headerlink" title="9、顶点着色器 VertextShader"></a>9、顶点着色器 VertextShader</h1><ul><li><p>一般用来处理图形每个顶点变换【旋转、平移、投影等】。</p></li><li><p>顶点着色器是OpenGl 中用于计算顶点属性的程序。顶点着色器是逐顶点运算的程序，也就是说每个顶点数据都会执行一次顶点着色器，当然这是并行的，并且顶点着色器运算过程中无法访问其他顶点的数据。</p></li><li><p>一般来说典型的需要计算的顶点属性主要包括顶点坐标变换、逐顶点光照运算等。顶点坐标由自身坐标系转换到归一化坐标系的运算，就是这这里发生的。</p></li></ul><h1 id="10、片元着色器程序-FragmentShader"><a href="#10、片元着色器程序-FragmentShader" class="headerlink" title="10、片元着色器程序 FragmentShader"></a>10、片元着色器程序 FragmentShader</h1><ul><li>一般用来处理图形中每个像素点颜色计算和填充。</li><li>也叫做像素着色器</li><li>片元着色器是OpenGL 中用于计算片段（像素）颜色的程序。片段着色器是逐像素运算的程序，也就是说每个像素都会执行一次片段着色器，当然也是并行的。</li></ul><h1 id="11、GLSL-OpenGL-Shading-Language"><a href="#11、GLSL-OpenGL-Shading-Language" class="headerlink" title="11、GLSL (OpenGL Shading Language)"></a>11、GLSL (OpenGL Shading Language)</h1><ul><li>OpenGL 着色语言（OpenGL Shading Language）是用来在OpenGL 中着色编程的语音，也即开发人员写的短小的自定义程序，他们在图形卡的GPU（Graphic Processor Unit 图形处理单元）上执行，代替了固定的渲染管线的一部分，使渲染管线中不同层次具有可编程性。比如：视图转换、投影转换等。 GLSL(GL Shading Language)的着色器代码分成2个部分：顶点着色器（<font color="red">VertexShader</font>）和片元着色器（<font color="red">FragmentShader</font>）</li></ul><h1 id="12、光栅化-Rasterization-不可编程"><a href="#12、光栅化-Rasterization-不可编程" class="headerlink" title="12、光栅化 Rasterization 不可编程"></a>12、光栅化 Rasterization 不可编程</h1><ul><li><p>是把顶点数据转换为片元的过程，具有将图转化一个个栅格组成的图像的作用。</p><ul><li>特点：每个元素对应帧缓冲区中的一像素。</li></ul></li><li><p>光栅化其实是一种将几何图元变为二维图像的过程。该过程包含了两部分的工作：</p><ul><li>第一部分工作：决定窗口坐标中的哪些整型栅格区域被基本图元占用；</li><li>第二部分工作：分配一个颜色值和一个深度值到各个区域，光栅化过程产生的片元。</li></ul></li><li><p>把物体的数学描述以及与物体相关的颜色信息转换为屏幕上用于对应位置的像素以及用于填充像素的颜色。这个过程称为光栅化，这是一个将模拟信号转化为离散信号的过程。</p></li></ul><h1 id="13、纹理"><a href="#13、纹理" class="headerlink" title="13、纹理"></a>13、纹理</h1><ul><li>纹理可以理解为图片，在渲染图片时需要在其编码填充图片，为了使得场景更加逼真。而这里使用的图片。就是常说的纹理，但是在OpenGL，我们更加习惯称为纹理。</li></ul><h1 id="14、混合-Blending"><a href="#14、混合-Blending" class="headerlink" title="14、混合 Blending"></a>14、混合 Blending</h1><ul><li>在测试阶段之后，如果像素依然没有被剔除，那么像素的颜色将会和帧缓冲区颜色附着上的颜色进行混合，混合的算法可以通过OpenGL 的函数进行指定。但是OpenGL 提供的混合算法是有限的，如果需要更加复杂的混合算法，一般可以通过像素着色器进行实现，当前性能会比原生的混合算法差一些。</li></ul><h1 id="15、变换矩阵-Transformation-、投影矩阵Projection"><a href="#15、变换矩阵-Transformation-、投影矩阵Projection" class="headerlink" title="15、变换矩阵 Transformation 、投影矩阵Projection"></a>15、变换矩阵 Transformation 、投影矩阵Projection</h1><ul><li>变换矩阵: 例如图形想发生平移、缩放、旋转变换，就需要使用变换矩阵。</li><li>投影矩阵：用于将3D坐标转换为二维屏幕坐标，实际线条也将在二维坐标下进行绘制。</li><li>投影方式： camera(观察者视角) ：有且只有2种<ul><li>正投影（平行投影）图片绘制不管远近1：1 进行绘制。一般用来显示2D效果。</li><li>透视投影：符合远小近大，用来显示3D效果。</li></ul></li></ul><h1 id="16、渲染上屏-交换缓冲区（SwapBuffer）"><a href="#16、渲染上屏-交换缓冲区（SwapBuffer）" class="headerlink" title="16、渲染上屏/交换缓冲区（SwapBuffer）"></a>16、渲染上屏/交换缓冲区（SwapBuffer）</h1><ul><li><p>渲染缓冲区⼀一般映射的是系统的资源⽐比如窗⼝口。如果将图像直接渲染到窗⼝口对应的渲染缓冲区，则可以 将图像显示到屏幕上。</p></li><li><p>但是，值得注意的是，如果每个窗⼝口只有⼀一个缓冲区，那么在绘制过程中屏幕进⾏行行了了刷新，窗⼝口可能显 示出不不完整的图像</p></li><li><p>为了了解决这个问题，常规的OpenGL程序⾄至少都会有两个缓冲区。显示在屏幕上的称为屏幕缓冲区，没有 显示的称为离屏缓冲区。在⼀一个缓冲区渲染完成之后，通过将屏幕缓冲区和离屏缓冲区交换，实现图像 在屏幕上的显示。</p></li><li><p>由于显示器器的刷新⼀一般是逐⾏行行进⾏行行的，因此为了了防⽌止交换缓冲区的时候屏幕上下区域的图像分属于两个 不不同的帧，因此交换⼀一般会等待显示器器刷新完成的信号，在显示器器两次刷新的间隔中进⾏行行交换，这个信 号就被称为垂直同步信号，这个技术被称为垂直同步</p></li><li><p>使⽤用了了双缓冲区和垂直同步技术之后，由于总是要等待缓冲区交换之后再进⾏行行下⼀一帧的渲染，使得帧率 ⽆无法完全达到硬件允许的最⾼高⽔水平。为了了解决这个问题，引⼊入了了三缓冲区技术，在等待垂直同步时，来 回交替渲染两个离屏的缓冲区，⽽而垂直同步发⽣生时，屏幕缓冲区和最近渲染完成的离屏缓冲区交换，实 现充分利利⽤用硬件性能的⽬目的</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>OpenGL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01、图形API简介</title>
    <link href="/2020/08/22/OpenGL/01%20%E5%9B%BE%E5%BD%A2API%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/08/22/OpenGL/01%20%E5%9B%BE%E5%BD%A2API%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1、图形API简介"><a href="#1、图形API简介" class="headerlink" title="1、图形API简介"></a>1、图形API简介</h1><ul><li><p><strong>OpenGL(Open Graphics Library)</strong> 是⼀个跨编程语言、跨平台的编程图形程序接⼝，它将计算机的资源抽象称为⼀个<strong>OpenGL</strong>的对象，对这些资源的操作抽象为⼀个个<strong>OpenGL</strong>指令。<br>OpenGL主要针对PC图形图像渲染处理（MAC/Windows）</p></li><li><p><strong>OpenGL ES(OpenGL for Embedded Systems)</strong> 是<strong>OpenGL</strong> 三维图形API 的子集， 针对手机、PDA 和 游戏主机等嵌入式设备而设计，去除了许多不必要和性能较低的API 接口。<br>OpenGL ES 主要针对移动端（iOS/安卓）</p></li><li><p><strong>DirectX</strong> 是由很多API组成的， DirectX是属于Windows 上一个多媒体处理框架，不支持Windows 以外的平台，不属于跨平台框架。<br>按照性质分类： 显示部分，声音部分，输入部分和网络部分。</p></li><li><p><strong>Metal</strong> Apple 为游戏开发者推出了新的平台技术Metal , 该技术能够为 3D 图像提高 <strong>10倍</strong> 的渲染性能。 Metal 是 Apple 为了解决3D 渲染而推出的框架。</p></li></ul><p>OpenGL/OpenGL ES / Metal 在项目中解决问题的本质：就是利用GPU 芯片来高效渲染图形图像。</p><p>OpenGL 和 OpenCV 的区别<br>OpenGL 用来渲染的（显示—&gt;位图）<br>OpenCV 用来识别的（人脸识别/身份识别/物体—&gt; OpenCV face++） —–&gt; 与人工智能结合</p><hr><h1 id="2、图片API-目的是解决什么问题"><a href="#2、图片API-目的是解决什么问题" class="headerlink" title="2、图片API 目的是解决什么问题"></a>2、图片API 目的是解决什么问题</h1><p>简单来说就是实现图形的底层渲染。比如以下场景：</p><ul><li>游戏开发中，对于游戏场景、人物的渲染。</li><li>音视频开发中，对于视频编码后的数据渲染。</li><li>地图引擎，对于地图上数据渲染。</li><li>核心动画中，实现动画的绘制。</li><li>视频处理中，对于视频加上滤镜效果等。</li><li>图片处理，滤镜、特效等。</li></ul>]]></content>
    
    
    <categories>
      
      <category>OpenGL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01、复杂度</title>
    <link href="/2020/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01%20%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2020/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01%20%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="1、什么是算法"><a href="#1、什么是算法" class="headerlink" title="1、什么是算法"></a>1、什么是算法</h2><ul><li>算法是用来解决特定问题的一系列的执行步骤</li><li>使用不同的算法，解决同一个问题，效率可能相差非常大</li></ul><h2 id="2、如何判断一个算法的好坏"><a href="#2、如何判断一个算法的好坏" class="headerlink" title="2、如何判断一个算法的好坏"></a>2、如何判断一个算法的好坏</h2><ul><li>正确性、可读性、健壮性（对不合理输入的反应能力和处理能力）</li><li>时间复杂度（time complexity） : 估算程序指令的执行次数（执行时间）</li><li>空间复杂度（space complexity）: 估算所需占用的存储空间</li><li><h2 id="3、大O-表示法（Big-O）"><a href="#3、大O-表示法（Big-O）" class="headerlink" title="3、大O 表示法（Big O）"></a>3、大O 表示法（Big O）</h2></li><li>一般用大O表示法来描述复杂度，它表示的是数据规模n 对应的复杂度</li><li>忽略常数、系数、低阶<ul><li>9 &gt;&gt; O(1)</li><li>2n + 3 &gt;&gt; O(n)</li><li>n^2 + 2n + 6 &gt;&gt; O(n^2)</li><li>4n^3 + 2n^2 + 6 &gt;&gt; O(n^3)</li></ul></li><li>注意： 大O表示法仅仅是一种粗略的分析模型，是一种估算，能帮助我们短时间了解一个算法的执行效率</li></ul><h2 id="4、对数阶的细节"><a href="#4、对数阶的细节" class="headerlink" title="4、对数阶的细节"></a>4、对数阶的细节</h2><ul><li>对数阶一般忽略底数 $log_2{n}$ = $log_2{9}$ * $log_9{n}$</li><li>所以 $log_2{n}$  、 $log_2{9}$ 统称为 $log_{n}$</li></ul><h2 id="5、常见的复杂度"><a href="#5、常见的复杂度" class="headerlink" title="5、常见的复杂度"></a>5、常见的复杂度</h2><table><thead><tr><th align="center">执行次数</th><th align="center">复杂度</th><th align="center">非正式术语</th></tr></thead><tbody><tr><td align="center">12</td><td align="center">O(1)</td><td align="center">常数阶</td></tr><tr><td align="center">2n + 3</td><td align="center">O(n)</td><td align="center">线性阶</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
